# Лекция 3

Тут пропущен некоторый контент. Ниже мы начинаем с реляционной алгебры.

Определения: ряляционная алгебра - замкнутая система операций над отношениями в реляционной модели данных
Операции принимают на вход одно или два отношения и выдают отношение. Например:
Унарные: выборка, проекция, переименование;
Бинарные: прямое произведение, объединение.

Всё это теоретические основы ряляционных баз данных. [Это могут спросить на экзамене. Например, надо по подобным операциям задать запрос и наоборот].

## Выборка

Выбирает кортежи из заданног оотношения, можно использовать операторы =, !=, >, <, >=, <=. А также можно использовать логические операции AND, OR и т.д.

## Проекция

Отбрасывает атрибуты.

## Композиция

Т.к. у нас алгебра и есть замкнутость операций, то мы можем бырть композицию операций.

## Прямое произведение

Сопоставляет каждую строку r1 с каждой строкой r2, однако действует не как прямое произведение множеств, где получаются пары (t1, t2), а конкатенирует обе строки. Обозначается r1 × r2. Возможен конфликт имен, разрешается через “.”, например: t1.x, t2.y, где t1 и t2 это таблицы, а x и y -- атрибуты.

## Соединение

## Эквивалентные запросы

Основы работы движков оптимизации. Движов смотрит на SELECT ... и принимает решение, а какие операции применить, чтобы было подешевле.
В разных системах есть hint'ы, и они, в отличии от SQL, отличаются. Ханты -- указания по тому, а как делать раличные операции. Например, делать сортировку быстро или слиянием.

И надо знать, что операции обладают приятными свойствами как дистрибутивность, ассоциативность и т.д.

## Другие операции

| id  | name | skill | salary |
|-----|------|-------|--------|
|  1  | Vasya| C++   | 100    |
|  2  | Petya| Java  | 90     |
|  3  | Ivan | C++   | 150    |
|  4  | Petr | C++   | 50     |
|  5  | Ser  | Java  | 60     |
|  6  | Alex | Py    | 80     |

SQL нужны для формирования отчётов(для начальства, например). Задача -- порезать бюджет и уволить самый дорогой отдел.
Атрибутом группировки будет Skill -- получим три класса. А что будет после группировки? Мы включим атрибуты грппировки, но и ещё некоторые аггрегирующие выражения.

```
SELECT SUM(salary), skill
FROM T
GROUP BY skill;
```

Name выбрать мы не можем, т.к. а какое имя нужно выбрать? Тут мы видим нарушение реляционной алгебры. Хотя и есть движки, которые на этом не ломаются.


Существует ещё объединение таблиц, при которой мы к одной таблице присоединями другую(но для этого должны совпадать атрибуты).

## Исчисление с кортежами

Запросы выглядят как {t | P(t)}, где t -- кортежи, P -- предикат. А если надо выдать только один атрибут, то надо немного помучаться с добавлением новой переменной. Аналогично для объединения таблиц. *в презентации больше примеров конкретных предикатов*

В реляционном исчилении доменов наши записи выглядят понятнее, мы оперирум не перменной, а кортежами.

