# Лекция 12

Тут всякая солянка, куча всяких долгов.

## Временные таблицы

Доступна только из одной сессии. Создаётся с помощью CREATE TEMPORARY. Удаляется в конце сессии.

Ещё они могут закрыть обычную "таблицу", т.е. если мы создадим временную с тем же названием, что и обычную, то запросы будут обращаться к временной.

Временная таблица не делает логирований и создать её дешевле чем обычную + есть механизмы транзакций.

## Представления 

Это виртуальные таблицы, которые не существуют в виде физических данных. Он своего рода запрос, мы просто описываем его. Они могут строиться с использованием других VIEW, такая вот иерархия. Нужны для упрощения запросов, безопасности(скрывает часть информации о пользователе; показываем только определённые атрибуты и определённые строки). И определяет интерфейс для данных, который избавит от проблем с добавлением атрибутов в таблицу. Все нужные мы указали, и больше пользователю не доступно. VIEW работает на этапе запроса, это виртуальная штука.

Можем также делать INSERT, UPDATE, DELETE. Есть условия обновляемости.

## VALUES

```sql
VALUES (1, 'one'), (2, 'two'), (3, 'three');
```

Эквивалентно 

1 | one

2 | two

3 | three


## Recursive VIEW

Знакомо с практик, мы просто делаем обход в ширину. Можем впихнуть в VIEW.

## Материализованные представления

Тут уже хранят данные. Синтаксис: CREATE MATERIALIZED VIEW. Зачем нужно? Пример: делам анализ данных, есть таблица с invoice. Данных много, анализировать сложно, поэтому решили сделать материализованное представление, которое строится не по запросу пользователя, а сразу для всех. Запускается она по ночам. Для быстрого обновления данных используется INDEX(см. слайды).

У обычного VIEW просто переписывается запрос, своего рода макрос, а тут уже храним данные. Materialized view даёт понять, что таблица не уникальная, берет данные из имеющихся таблиц + удобный интерфейс обновления и внутри есть необходимые механизмы.

## Приведение типов

Пример:
```sql
CAST('100', integer)
```

Есть уйма всяких типов данных, на практике применяли.
Можем писать условия, по которым будем кастить данные.

## COALESCE

Возвращает первый not null. С помощью него можно обрабатывать и NULL, COALESCE(data.column, 0).

## Контроль доступа

Можем для определённых ролей настраивать сложные настройки: включение/отключение триггеров и т.д.
Синтаксис:
```sql
CREATE ROLE myname;
```
Есть групповые роли, чтобы раздать многим одну и ту же роль. Есть наследование ролей.

### Привилегии 

С использованием GRANT(дать)/REVOKE(забрать). Даем привилегии ролям. Бывают привилегии на колонку(выбор, обновление удаление и т.д.), да и вообще всякие бывают.

## Курсоры
(Спойлер: считаются плохой практикой: необходимое зло. Если делаете на собесе, то, скорее всего, что-то не так)


Есть страх: база может прислать пару гигов информации. Чтобы этого избежать придумали курсоры -- помогают проходить построчно большой результат.

Синтаксис:
```sql
DECLARE
    curs1 refcursor;
    curs2 CURSOR FIR SELECT * FROM tenk1;
```

Что можно делать? Можем открывать с OPEN.

Можем открыть привязанный курсор.

Как пользоваться? С помощью FETCH -- кладёт строку в переменные, row variable, ... . Можно мыслить всем этим как итераторами. Курсор, ка и итератор, можно МУВать, т.е. сдвигать. Под курсором можно удалять или обновлять.

## RETURN NEXT

В C# есть слово yield, вот тут уже это есть. Т.е. мы не просто отработали и вернули, а копим результат.