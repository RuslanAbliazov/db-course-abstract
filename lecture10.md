# Лекция 10

## Ranking

Мы хотим упорядочить данные и сгруппировать на основании этого объекты. 
Код:
```sql
SELECT ID, RANK() OVER (ORDER BY (GPA) DESC) AS s_rank
FROM student_grades;
```
Не всегда у нас будет один и тот же результат. Зависит от среды(СУБД и её версия), внешние условия. Подробнее на курсе по движкам БД. В общем, нормальные юнит-тесты не написать.

Может быть такое, что встретятся равные по ГПА студенты в таблице, тогда ранги будут 1, 1, 3. Чтобы избежать этого используют dense_rank(), тогда будет 1,2,3. Как он посортуриует внутри -- непонятно.

С нулами проблема, нулевые строки будут иметь высший ранк. Но это тоже фиксится.

## Ranking на партциях

Иногда хочется делать ранкинг внутри какой группы. Тогда пишем 
```sql
RANK() OER BY PARTITION ...
```

Можем считать много рангов. Значения агрегационных данных могут использоваться для вычисления ранга. В случае больших результатов хочется взять топ Н записей.

Н лучших записей можно выбрать с помощью LIMIT. Не в PostgeSQL используются другие слова.

## Оконные функции

Что это такое? Хочется взять окрестность каждой строчки и что-то сделать. Мы делаем окно, и оно проходит по каждой строчке. Не все системы поддерживают, но можно это симулировать. Синтаксис
```sql
SELECT year, avg(num_credits)
    OVER (ORDER BY year rows 3 preceding
    as tot_credits)
from tot_credits;
```
Окна могут увеличиваться. А что если хотим N записей спереди, M сзади?
Тогда пишем 3 preceding and 2 following.

С помощью partition by выделили группы. Внутри можем быть order by. Затем проходимся рамкой: есть разные ключевые слова для задания размера.

### Всякие примеры

В Оракле есть ключевое слово window, которое даже позволяет считать несколько агрегирующих функций. 

Вообще не всегда будет возможность написать то, как мы хотим, т.к. что-то совсем ново, а мы работаем на старой системе, тогда надо уметь выкручиваться и заменять другими функциями.

#### Pivot

Есть БД из товаров и наличия: размер, цвет, число и т.д.. Надо получить всевозможные комбинации по типам одежды и размерам и посчитать сколько было продано по цветам. При том у нас будут создаваться новые колонки по цветам(зависит от количества цветов, может), такое с GROUP BY мы не сделаем. 
```sql
SELECT * FROM sales PIVOT (SUM(quantity) for color in ('dark', 'pastel', 'white'))
```

#### Rollup and cube

Обобщение GROUP BY. rollup(item_name, color) Смотри на 3 группировки по префиксам. и объединяет. Т.е. мы можем посмотреть сколько было продано синих штанов, штанов, синих вещей и всего вещей.

Для красоты хотим заменить null на all, чтобы в отчётах было красиво написано.

## Insert/Update/Delete

Было на практиках, тут понятные действия, которые можно сделать с БД. 

Вставка данных может быть очень дорогой, т.к. под капотом есть логгирование и прочее-прочее.

