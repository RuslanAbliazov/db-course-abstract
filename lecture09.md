# Лекция 9

## Замечание про multiset реляционнную алгебру

Подзапросов тут нет, но есть полусоединение и антисоединение. *Тут ещё что-то есть, см. слайды*

## Соединения

По типу и по условию.

### Естественное соединение

Соединяем по значениям атрибутов, которые имеют одно и то же название. Разумно ожидать совпадения в именах схем. Концептуально отличается от прямого произведения + предиката. Повторов тут нет. Используется natural join. Результат -- отношение. Можем писать несколько join'ов подряд.

Cross join -- декартово произведение. Соединяет все со всеми.
Примечание: когда пишем джойны, то всё обрабатывается слева направо.
Что если делаем цепочку natural join? Могут быть некоторые нюансы, см. слайды.

Можно использовать using, явно указываем по какому атрибуту(атрибутам) соединяем.

Можно использовать слово ON, аналог WHERE. Иногда он работает по-другому, да ещё можно делать код более читаемым.
Но когда мы пишем ON, то мы у нас не будет дубликатов атрибутов, по которым мы джойним. Например, мы джойним по двум айдишникам. В коде с where у нас будет два формально разных айдишника, но по сути одинаковых, это проблему с дубликатом решает ON.

### Внешние соединения

При соединении теряется некоторая информация(например, если мы хотим поматчить студентов с курсами, а мы хотим в таблице студента, который курс не взял). Для этого есть соединения, которые поставят нулы в абтриубты у тех строчек, которые не сматчили. Это left/right outer join.

Можно добить нулами как левые, так и правые. Это полное внешнее соединение. 

Зачем нужны два синтаксиса ON и WHERE? концептуально ON это спецификация внешнего соединения, но не WHERE. Это must have внешних соединений.

Перейдём к более содержательным вещам.

## pivot, rollup & cube

Иными словами -- продвинутая агрегация.

Рекурсивные запросы. Например, для таблицы курсов для каждого курса хочется найти все пререквизиты. Т.е. у нас есть данные, которые можно представить в виде графа. А по нему хочется делать всё что знаем: BFS, DFS, транзитивное замыкание и т.д.
Оффтоп: можем писать императивный код в нашем декларативном языке SQL.

Чтобы решить нашу проблему, можем написать функцию и походить по таблице. Мы инициализируем стартовое множество, а затем добавляем новые и новые строки, не добавляя те строки, которые мыы уже добавили.

Можем писать рекурсивные запросы, для этого есть свой синтаксис.

```sql
WITH RECURSIVE rec_prereq(course_id, prereq_id) AS (
    SELECT course_idm prereq_id
    FROM prereq

    UNION

    SELECT rec_prereq.course_id, prereq_id
    FROM rec_prereq, prereq
    WHERE rec_prereq.prereq_id = prereq_course_id
)

SELECT * FROM rec_prereq;
```

До UNION стартовое множество, а дополняется оно будет строками после UNION.

И это был базовый синтаксис, который есть везде. Разные корпорации делают по-своему, и они даже добавляют новый функционал!

## Ranking 

Это в следующий раз