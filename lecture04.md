# Лекция 4

Тут мы будем понимать, что происходит при написании запросов в движке СУБД.
Под капотом у нас работа с деревьями(не всегда, но будем работать с деревьями).

Сначала происходит синтаксический анализ запроса. После этого мы строим логический план запроса(тут мы не учитываем физический аспект БД, обговорим позже). Потом уже учитываем то, сколько у нас памяти и т.д. Затем выполняем запрос.

Парсер -- синтаксический анализатор(строит синтаксическое дерево) -- отправляет свой результат в оптимизатор.

Разберём запрос:
## Синтаксический анализ

Делается просто с помощью Flex, Bison. На входе представляется внутреннее представление, дерево запроса. Под капотом всё построено с помощью формальных грамматик(см. курс Теоретической информатики).

Препроцессор проверяет контроль типов, осуществляет семантический контроль.
Сам запрос собирается из набора реляционных операторов по определённым правилам. Используется реляционная алгебра и теоретико-множественный операции, их можем комбинировать.

Далее рассматриваем конкретное выражение и его синтаксическое дерево:
```
SELECT title, lastName 
FROM Employees AS e, Departments AS d 
WHERE d.dept_name = 'Eng' AND year(e.birthday) >= 1970;
```

Как это работает? Сначала мы читаем таблицы, потом JOINим их, затем применяем предикат, а потом используем проекции. *Картинка из слайдов*

## Оптимизации

Неоптимальность в том, что мы не спустили предикаты вниз к исходным таблицам. Нам надо распотрошить таблицы! Идея опускать предикат под JOIN -- эвристическая оптимизация. Но это старый подход.

Рассмотрим другой план над другой БД. Другой способ оптимизировать -- смотреть на данные  стоимости. Этим занимается стоимостной оптимизатор(такой есть в постгресе, например).

Ещё одна техника оптимизации -- мы можем спустить вниз проекцию, нам же не всё нужно в итоговом запросе.

Планы оптимизации могут быть разными. Их может быть много, они могут быть разными по оптимальности. И их редко можно переиспользовать. 
Вычисление оптимального плана -- NP-трудная задача.

Иногда используют стоимостные модели + эвристические методы(см. [практики по мат. основам алгоритмов](http://acm.math.spbu.ru/~gassa/bachelor-2022/230324_b22_slides.ru.pdf)).

У нас есть Rewriter, от которого потом идём в Planner. Планировщик работает с алгебраическим пространством, также использует информацию о данных, может  использовать индексы. Также использует стоимостную модель(содержит информацию о количестве данных, статистиках).

Хорошо, пусть у нас есть план, его надо выполнить.

Мы построили дерево, а теперь мы строим дерево для итераторов, которые имеют левый и правые потомки, которые тоже итераторы. У верхнего оператора мы вызываем. Вообще тут сложная машинерия и это надо пояснить.

## Реализация выборки

Используются индексы. Мы знаем про B дерево, и мы будем строить его на индексах, в вершинах хранится смещения данных на диске. Таким образом имеет быстрый поиск.

Реализация соединения: Nested loop -- ничего хитрого, квадратичная сложность. Можно сделать Hash-Join, хэшиурем одну таблицу, а потом соединяем.